# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Overview

xv6 is a re-implementation of Unix Version 6 for x86 multiprocessors, used for OS education. This repository has a custom **Sprite LFS (Log-Structured File System)** implementation replacing the original xv6 filesystem.

**Note**: The x86 version is no longer maintained upstream. The active version is at https://github.com/mit-pdos/xv6-riscv.git

## Build Commands

```bash
# Build everything
make

# Clean build artifacts
make clean

# Run in QEMU with graphics
make qemu

# Run in QEMU without graphics (recommended for terminal use)
make qemu-nox

# Run with GDB debugging (starts QEMU with GDB stub)
make qemu-gdb
# Then in another terminal: gdb (uses .gdbinit automatically)

# Run with in-memory filesystem
make qemu-memfs

# Specify number of CPUs (default: 2)
make qemu CPUS=4
```

## Testing

```bash
# Inside xv6 shell:
usertests       # Comprehensive test suite
usertests -q    # Quick version
stressfs        # Filesystem stress test
forktest        # Process forking test
```

## Architecture

### Kernel Subsystems

| Component | Files | Purpose |
|-----------|-------|---------|
| Memory | vm.c, kalloc.c, memlayout.h | Virtual memory, page allocation |
| Process | proc.c, proc.h, swtch.S | Process table, scheduling, context switch |
| Filesystem | fs.c, fs.h, log.c | LFS implementation |
| Devices | ide.c, console.c, uart.c, kbd.c | Disk, console, serial, keyboard |
| Interrupts | trap.c, trapasm.S, vectors.S | Trap handling (vectors.S auto-generated by vectors.pl) |
| Syscalls | syscall.c, sysfile.c, sysproc.c | 21 system calls |
| Sync | spinlock.c, sleeplock.c | Kernel locks |

### LFS Implementation (Custom)

The filesystem uses log-structured design with:
- **Disk layout**: `[boot | super | checkpoint0 | checkpoint1 | log segments...]`
- **Checkpoint**: Stores log_tail position and imap block locations
- **Imap**: Maps inode number to disk block address (encoded as `(block << 3) | slot`)
- **IPB=8**: 8 inodes per block for space efficiency
- **Dirty inode buffer**: Batches up to 8 inodes before sync
- **No GC**: Log grows until disk full (FSSIZE=50000 blocks)

Key runtime state in `fs.c`:
```c
struct {
  struct spinlock lock;
  uint imap[LFS_NINODES];      // inode -> disk location
  struct checkpoint cp;
  uint log_tail;               // next write position
  int dev;
} lfs;
```

Sync triggers: buffer full (8 inodes), periodic (30 sec), or panic.

### Key Parameters (param.h)

| Constant | Value | Purpose |
|----------|-------|---------|
| NPROC | 64 | Max processes |
| NCPU | 8 | Max CPUs |
| FSSIZE | 50000 | Filesystem blocks (~25MB) |
| LFS_NINODES | 200 | Max inodes |
| LFS_SEGSIZE | 64 | Segment size in blocks |
| NBUF | 30 | Buffer cache size |

### Memory Layout

- KERNBASE: 0x80000000 (kernel virtual base)
- PHYSTOP: 0xE000000 (228MB physical limit)
- Kernel loaded at physical 0x100000 (1MB)

## Adding Code

### New System Call
1. Add `SYS_name` constant to `syscall.h`
2. Implement in `sysfile.c` or `sysproc.c`
3. Add wrapper in `usys.S`: `SYSCALL(name)`
4. Declare in `user.h`
5. Add to syscalls[] array in `syscall.c`

### New User Program
1. Create `program.c`
2. Add `_program` to `UPROGS` in Makefile
3. Program links with `$(ULIB)` (ulib.c, usys.S, printf.c, umalloc.c)

### New Kernel Function
1. Implement in appropriate .c file
2. Add declaration to `defs.h`

## Locking Notes

- **Spinlocks**: For kernel critical sections (no sleep allowed while held)
- **Sleeplocks**: For I/O operations (can sleep while held)
- Never call `bread()` while holding a spinlock (it may sleep)
- Lock ordering documented in TRICKS file

## Build Artifacts

- `kernel` - Kernel ELF binary
- `fs.img` - Filesystem image (25MB)
- `xv6.img` - Bootable system image
- `mkfs` - Host tool to create fs.img
- `_*` - User programs (prefixed with underscore)
